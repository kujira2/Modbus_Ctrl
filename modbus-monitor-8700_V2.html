<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8700 Modbus確認用</title>
    <link rel="stylesheet" href="modbus-styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chart.js/3.7.0/chart.min.js"></script>
</head>

<body>
    <div class="container">
        <h1>8700 Modbus確認用</h1>

        <div class="comm-panel">
            <div class="comm-settings">
                <div class="setting-item">
                    <label for="baudRate">通信速度:</label>
                    <select id="baudRate">
                        <option value="9600">9600 bps</option>
                        <option value="19200">19200 bps</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label for="parity">パリティ:</label>
                    <select id="parity">
                        <option value="none">なし (None)</option>
                        <option value="even">偶数 (Even)</option>
                        <option value="odd">奇数 (Odd)</option>
                    </select>
                </div>
                <button id="connectButton" class="connect-button">接続</button>
                <span id="connectionStatus" class="status-text">未接続</span>
            </div>
        </div>

        <div class="status-panel">
            <div class="status-item">
                <span class="status-label">RUNキー状態:</span>
                <span id="runKeyStatus">読み込み中...</span>
            </div>
            <div class="status-item">
                <span class="status-label">設定モード:</span>
                <span id="settingMode">読み込み中...</span>
            </div>
            <div class="status-item">
                <span class="status-label">オートゼロ状態:</span>
                <span id="autoZeroStatus">読み込み中...</span>
            </div>
            <div class="status-item">
                <span class="status-label">0-2%表示設定:</span>
                <span id="displayMode">読み込み中...</span>
            </div>
            <div class="status-item">
                <span class="status-label">流量単位:</span>
                <span id="flowUnit">読み込み中...</span>
            </div>
        </div>

        <div class="control-panel">
            <button id="startTest" class="test-button" disabled>流量検査開始</button>
            <button id="stopTest" class="test-button stop-button" disabled>流量検査停止</button>
        </div>

        <div class="chart-container">
            <canvas id="flowChart"></canvas>
        </div>
    </div>

    <script type="module">
    import { ModbusCommands } from './modbus-commands.js';
    import { FlowChartManager } from './flow-chart.js';

        class SerialConnection {
            constructor() {
                this.port = null;
                this.reader = null;
                this.writer = null;
            }

            async connect() {
                try {
                    if (this.port) {
                        await this.disconnect();
                        this.port = null; // ポートをリセット
                    }
                    this.port = await navigator.serial.requestPort();
                    const baudRate = parseInt(document.getElementById('baudRate').value);
                    const parity = document.getElementById('parity').value;

                    // 明示的にポート選択を要求
                   this.port = await navigator.serial.requestPort();
                   console.log('Port selected');

                    // ポートを開く
                    await this.port.open({
                        baudRate: baudRate,
                        dataBits: 8,
                        stopBits: 1,
                        parity: parity,
                        bufferSize: 255
                    });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();
                    return true; 

                } catch (error) {
                    console.error('接続エラー:', error);
                    await this.disconnect();
                    return false;
                }
            }

            async disconnect() {
                try {
                    if (this.reader) {
                        await this.reader.cancel();
                        await this.reader.releaseLock();
                    }
                    if (this.writer) {
                        await this.writer.close();
                        await this.writer.releaseLock();
                    }
                    if (this.port) {
                        await this.port.close();

                    }
                } finally {
                    this.port = null;
                    this.reader = null;
                    this.writer = null;
                }
            }

            async sendCommand(command) {
                if (!this.writer) {
                    console.error('ライターが利用できません');
                    return null;
                }

                try {
                    console.log('コマンド送信:', Array.from(command).map(b => b.toString(16)));
                    await this.writer.write(command);
                    const response = await this.readResponse();
                    if (response) {
                        console.log('レスポンス受信:', Array.from(response).map(b => b.toString(16)));
                    } else {
                        console.log('レスポンスなし');
                    }
                    return response;
                } catch (error) {
                    console.error('送信エラー:', error);
                    return null;
                }
            }

            async readResponse() {
                if (!this.reader) {
                    console.error('リーダーが利用できません');
                    return null;
                }

                let timeoutId;
                try {
                    const response = [];
                    const timeoutPromise = new Promise((_, reject) => {
                        timeoutId = setTimeout(() => {
                            reject(new Error('タイムアウト'));
                        }, 1000);
                    });

                    while (true) {
                        const readPromise = this.reader.read();
                        const result = await Promise.race([readPromise, timeoutPromise]);
                        const { value, done } = result;

                        if (done) {
                            console.log('読み取り完了');
                            break;
                        }

                        response.push(...value);
                        if (response.length >= 3 && response.length >= response[2] + 5) {
                            break;
                        }
                    }

                    clearTimeout(timeoutId);
                    return new Uint8Array(response);

                } catch (error) {
                    console.error('読み取りエラー:', error);
                    if (timeoutId) clearTimeout(timeoutId);
                    return null;
                }
            }

            isConnected() {
                return this.port !== null && this.reader !== null && this.writer !== null;
            }
        }
        class ModbusMonitor {
                constructor() {
                    this.serialConnection = new SerialConnection();
                    this.chartManager = new FlowChartManager();
                    this.isTestRunning = false;
                    this.maxRange = 0;
                    this.updateInterval = null;
                    this.flowUpdateInterval = null;
                }

                async initialize() {
                    await this.chartManager.initialize();
                    this.setupEventListeners();
                }

                async determineFlowUnit() {
                    try {
                        // フルスケール値の読み取り (40028)
                        const rangeResponse = await this.serialConnection.sendCommand(
                            ModbusCommands.createReadFlowRateRange()
                        );

                        // 小数点位置の読み取り (40009)
                        const decimalPointResponse = await this.serialConnection.sendCommand(
                            ModbusCommands.createReadDecimalPoint()
                        );

                        if (!rangeResponse || !decimalPointResponse) {
                            console.error('Failed to read flow unit parameters');
                            return;
                        }

                        const rangeData = this.parseModbusResponse(rangeResponse);
                        const decimalPointData = this.parseModbusResponse(decimalPointResponse);

                        if (!rangeData || !decimalPointData) {
                            console.error('Invalid response data');
                            return;
                        }

                        const fullScale = rangeData[0];
                        const decimalPoint = decimalPointData[0];

                        // 小数点位置に基づいて実際のフルスケール値を計算
                        const actualFullScale = fullScale / Math.pow(10, decimalPoint);
                        this.maxRange = fullScale; // 生の値を保存

                        // 単位の決定
                        let unit = '';
                        if (actualFullScale < 1.0) {
                            unit = 'SCCM';
                        } else {
                            unit = 'SLM';
                        }

                        document.getElementById('flowUnit').textContent =
                            `${actualFullScale.toFixed(decimalPoint)} ${unit}`;
                        await this.chartManager.setYAxisUnit(unit);

                        console.log(`Flow unit set: ${unit}, Full scale: ${actualFullScale}, Decimal point: ${decimalPoint}`);
                    } catch (error) {
                        console.error('Error determining flow unit:', error);
                    }
                }

                async updateCoilStatus() {
                    const response = await this.serialConnection.sendCommand(
                        ModbusCommands.createReadCoilStatus()
                    );
                    if (!response) return;

                    const statusData = this.parseModbusResponse(response);
                    if (statusData) {
                        document.getElementById('runKeyStatus').textContent =
                            statusData[0] ? 'RUNキー使用中' : 'RUNキー不使用';
                        document.getElementById('settingMode').textContent =
                            statusData[1] ? 'アナログ設定' : 'デジタル設定';
                        document.getElementById('autoZeroStatus').textContent =
                            statusData[4] ? 'オートゼロ使用中' : 'オートゼロ不使用';
                        document.getElementById('displayMode').textContent =
                            statusData[5] ? '0-2％の時0表示' : '0-2%範囲表示';
                    }
                }

                async updateFlowRate() {
                    const response = await this.serialConnection.sendCommand(
                        ModbusCommands.createReadFlowRateOutput()
                    );
                    if (!response) return;

                    const flowData = this.parseModbusResponse(response);
                    if (flowData && flowData.length > 0) {
                        await this.chartManager.updateChart(flowData[0]);
                    }
                }

                parseModbusResponse(response) {
                    if (response && response.length >= 5) {
                        return Array.from(response.slice(3, -2));
                    }
                    return null;
                }

                updateButtonStates() {
                    const startButton = document.getElementById('startTest');
                    const stopButton = document.getElementById('stopTest');
                    const isConnected = this.serialConnection.isConnected();

                    startButton.disabled = !isConnected || this.isTestRunning;
                    stopButton.disabled = !isConnected || !this.isTestRunning;
                }

                async stopFlowTest() {
                    if (!this.isTestRunning) return;

                    // まずフラグを false に設定して他の処理を止める
                    this.isTestRunning = false;

                    try {
                        // 流量を0に設定
                        await this.serialConnection.sendCommand(
                            ModbusCommands.createWriteFlowRateSetpoint(0)
                        );
                        await this.sleep(1000);

                        // 制御モードを完全閉に設定
                        await this.serialConnection.sendCommand(
                            ModbusCommands.createWriteControlMode(2)
                        );

                        console.log('Flow test stopped successfully');
                    } catch (error) {
                        console.error('Flow test stop error:', error);
                    } finally {
                        this.updateButtonStates();
                    }
                }

                async runFlowTest() {
                    if (this.isTestRunning) return;

                    this.isTestRunning = true;
                    this.updateButtonStates();
                    await this.chartManager.startNewTest();

                    try {
                        await this.serialConnection.sendCommand(
                            ModbusCommands.createWriteControlMode(1)
                        );
                        await this.sleep(5000);

                        const testPoints = [0.2, 0.4, 0.6, 0.8, 1.0];
                        for (const ratio of testPoints) {
                            if (!this.isTestRunning) break;
                            const setValue = Math.floor(this.maxRange * ratio);
                            await this.serialConnection.sendCommand(
                                ModbusCommands.createWriteFlowRateSetpoint(setValue)
                            );
                            await this.sleep(10000);
                        }

                        if (this.isTestRunning) {
                            await this.stopFlowTest();
                        }

                    } catch (error) {
                        console.error('Flow test error:', error);
                        this.isTestRunning = false;
                        this.updateButtonStates();
                    }
                }

                setupEventListeners() {
                    document.getElementById('connectButton').addEventListener('click',
                        async () => {
                            if (!this.serialConnection.isConnected()) {
                                const connected = await this.serialConnection.connect();
                                if (connected) {
                                    document.getElementById('connectionStatus').textContent = '接続済み';
                                    document.getElementById('connectButton').textContent = '切断';
                                    await this.updateCoilStatus();
                                    await this.determineFlowUnit();
                                    this.startPeriodicUpdate();
                                    this.updateButtonStates();
                                }
                            } else {
                                await this.serialConnection.disconnect();
                                document.getElementById('connectionStatus').textContent = '未接続';
                                document.getElementById('connectButton').textContent = '接続';
                                this.stopPeriodicUpdate();
                                this.updateButtonStates();
                            }
                        });

                    document.getElementById('startTest').addEventListener('click',
                        () => this.runFlowTest());

                    document.getElementById('stopTest').addEventListener('click',
                        () => this.stopFlowTest());
                }

                startPeriodicUpdate() {
                    this.stopPeriodicUpdate();

                    // ステータス更新（1秒間隔）
                    this.updateInterval = setInterval(async () => {
                        await this.updateCoilStatus();
                    }, 1000);

                    // 流量データの更新（0.5秒間隔）
                    this.flowUpdateInterval = setInterval(async () => {
                        if (this.serialConnection.isConnected()) {
                            await this.updateFlowRate();
                        }
                    }, 500);
                }

                stopPeriodicUpdate() {
                    if (this.updateInterval) {
                        clearInterval(this.updateInterval);
                        this.updateInterval = null;
                    }
                    if (this.flowUpdateInterval) {
                        clearInterval(this.flowUpdateInterval);
                        this.flowUpdateInterval = null;
                    }
                }

                sleep(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }
            }

            // アプリケーション初期化
            if ('serial' in navigator) {
                const monitor = new ModbusMonitor();
                await monitor.initialize();
            } else {
                alert('このブラウザはWeb Serial APIをサポートしていません。\nChrome/Edge等の対応ブラウザをご使用ください。');
            }
        </script>
    </div>
    </body>
    
    </html>
    